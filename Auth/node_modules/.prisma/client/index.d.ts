
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model credenciales
 * 
 */
export type credenciales = {
  usuario: string
  contrasena: string
}

/**
 * Model estudiantes
 * 
 */
export type estudiantes = {
  codigo: number
  nombre: string
  apellido: string
  tipo_documento: string
  numero_documento: string
  estado: string | null
  genero: string | null
  path: string
}

/**
 * Model inscripciones
 * 
 */
export type inscripciones = {
  id_inscripcion: number
  codigo_estudiante: number
  codigo_materia: number
  fecha_inscripcion: Date
}

/**
 * Model materias
 * 
 */
export type materias = {
  codigo: number
  nombre: string
  cupos: number | null
  estado: string | null
}

/**
 * Model usuarios
 * 
 */
export type usuarios = {
  nombre_usuario: string
  correo_electronico: string
  estado: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Credenciales
 * const credenciales = await prisma.credenciales.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Credenciales
   * const credenciales = await prisma.credenciales.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.credenciales`: Exposes CRUD operations for the **credenciales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credenciales
    * const credenciales = await prisma.credenciales.findMany()
    * ```
    */
  get credenciales(): Prisma.credencialesDelegate<GlobalReject>;

  /**
   * `prisma.estudiantes`: Exposes CRUD operations for the **estudiantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudiantes
    * const estudiantes = await prisma.estudiantes.findMany()
    * ```
    */
  get estudiantes(): Prisma.estudiantesDelegate<GlobalReject>;

  /**
   * `prisma.inscripciones`: Exposes CRUD operations for the **inscripciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscripciones
    * const inscripciones = await prisma.inscripciones.findMany()
    * ```
    */
  get inscripciones(): Prisma.inscripcionesDelegate<GlobalReject>;

  /**
   * `prisma.materias`: Exposes CRUD operations for the **materias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materias
    * const materias = await prisma.materias.findMany()
    * ```
    */
  get materias(): Prisma.materiasDelegate<GlobalReject>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.usuariosDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.13.0
   * Query Engine version: 1e7af066ee9cb95cf3a403c78d9aab3e6b04f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    credenciales: 'credenciales',
    estudiantes: 'estudiantes',
    inscripciones: 'inscripciones',
    materias: 'materias',
    usuarios: 'usuarios'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EstudiantesCountOutputType
   */


  export type EstudiantesCountOutputType = {
    inscripciones: number
  }

  export type EstudiantesCountOutputTypeSelect = {
    inscripciones?: boolean
  }

  export type EstudiantesCountOutputTypeGetPayload<S extends boolean | null | undefined | EstudiantesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EstudiantesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EstudiantesCountOutputTypeArgs)
    ? EstudiantesCountOutputType 
    : S extends { select: any } & (EstudiantesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EstudiantesCountOutputType ? EstudiantesCountOutputType[P] : never
  } 
      : EstudiantesCountOutputType




  // Custom InputTypes

  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EstudiantesCountOutputType
     */
    select?: EstudiantesCountOutputTypeSelect | null
  }



  /**
   * Count Type MateriasCountOutputType
   */


  export type MateriasCountOutputType = {
    inscripciones: number
  }

  export type MateriasCountOutputTypeSelect = {
    inscripciones?: boolean
  }

  export type MateriasCountOutputTypeGetPayload<S extends boolean | null | undefined | MateriasCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MateriasCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MateriasCountOutputTypeArgs)
    ? MateriasCountOutputType 
    : S extends { select: any } & (MateriasCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MateriasCountOutputType ? MateriasCountOutputType[P] : never
  } 
      : MateriasCountOutputType




  // Custom InputTypes

  /**
   * MateriasCountOutputType without action
   */
  export type MateriasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MateriasCountOutputType
     */
    select?: MateriasCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model credenciales
   */


  export type AggregateCredenciales = {
    _count: CredencialesCountAggregateOutputType | null
    _min: CredencialesMinAggregateOutputType | null
    _max: CredencialesMaxAggregateOutputType | null
  }

  export type CredencialesMinAggregateOutputType = {
    usuario: string | null
    contrasena: string | null
  }

  export type CredencialesMaxAggregateOutputType = {
    usuario: string | null
    contrasena: string | null
  }

  export type CredencialesCountAggregateOutputType = {
    usuario: number
    contrasena: number
    _all: number
  }


  export type CredencialesMinAggregateInputType = {
    usuario?: true
    contrasena?: true
  }

  export type CredencialesMaxAggregateInputType = {
    usuario?: true
    contrasena?: true
  }

  export type CredencialesCountAggregateInputType = {
    usuario?: true
    contrasena?: true
    _all?: true
  }

  export type CredencialesAggregateArgs = {
    /**
     * Filter which credenciales to aggregate.
     */
    where?: credencialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credenciales to fetch.
     */
    orderBy?: Enumerable<credencialesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credencialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credenciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credenciales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credenciales
    **/
    _count?: true | CredencialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredencialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredencialesMaxAggregateInputType
  }

  export type GetCredencialesAggregateType<T extends CredencialesAggregateArgs> = {
        [P in keyof T & keyof AggregateCredenciales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredenciales[P]>
      : GetScalarType<T[P], AggregateCredenciales[P]>
  }




  export type CredencialesGroupByArgs = {
    where?: credencialesWhereInput
    orderBy?: Enumerable<credencialesOrderByWithAggregationInput>
    by: CredencialesScalarFieldEnum[]
    having?: credencialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredencialesCountAggregateInputType | true
    _min?: CredencialesMinAggregateInputType
    _max?: CredencialesMaxAggregateInputType
  }


  export type CredencialesGroupByOutputType = {
    usuario: string
    contrasena: string
    _count: CredencialesCountAggregateOutputType | null
    _min: CredencialesMinAggregateOutputType | null
    _max: CredencialesMaxAggregateOutputType | null
  }

  type GetCredencialesGroupByPayload<T extends CredencialesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CredencialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredencialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredencialesGroupByOutputType[P]>
            : GetScalarType<T[P], CredencialesGroupByOutputType[P]>
        }
      >
    >


  export type credencialesSelect = {
    usuario?: boolean
    contrasena?: boolean
    usuarios?: boolean | usuariosArgs
  }


  export type credencialesInclude = {
    usuarios?: boolean | usuariosArgs
  }

  export type credencialesGetPayload<S extends boolean | null | undefined | credencialesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? credenciales :
    S extends undefined ? never :
    S extends { include: any } & (credencialesArgs | credencialesFindManyArgs)
    ? credenciales  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuarios' ? usuariosGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (credencialesArgs | credencialesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuarios' ? usuariosGetPayload<S['select'][P]> :  P extends keyof credenciales ? credenciales[P] : never
  } 
      : credenciales


  type credencialesCountArgs = 
    Omit<credencialesFindManyArgs, 'select' | 'include'> & {
      select?: CredencialesCountAggregateInputType | true
    }

  export interface credencialesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Credenciales that matches the filter.
     * @param {credencialesFindUniqueArgs} args - Arguments to find a Credenciales
     * @example
     * // Get one Credenciales
     * const credenciales = await prisma.credenciales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends credencialesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, credencialesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'credenciales'> extends True ? Prisma__credencialesClient<credencialesGetPayload<T>> : Prisma__credencialesClient<credencialesGetPayload<T> | null, null>

    /**
     * Find one Credenciales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {credencialesFindUniqueOrThrowArgs} args - Arguments to find a Credenciales
     * @example
     * // Get one Credenciales
     * const credenciales = await prisma.credenciales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends credencialesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, credencialesFindUniqueOrThrowArgs>
    ): Prisma__credencialesClient<credencialesGetPayload<T>>

    /**
     * Find the first Credenciales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesFindFirstArgs} args - Arguments to find a Credenciales
     * @example
     * // Get one Credenciales
     * const credenciales = await prisma.credenciales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends credencialesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, credencialesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'credenciales'> extends True ? Prisma__credencialesClient<credencialesGetPayload<T>> : Prisma__credencialesClient<credencialesGetPayload<T> | null, null>

    /**
     * Find the first Credenciales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesFindFirstOrThrowArgs} args - Arguments to find a Credenciales
     * @example
     * // Get one Credenciales
     * const credenciales = await prisma.credenciales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends credencialesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, credencialesFindFirstOrThrowArgs>
    ): Prisma__credencialesClient<credencialesGetPayload<T>>

    /**
     * Find zero or more Credenciales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credenciales
     * const credenciales = await prisma.credenciales.findMany()
     * 
     * // Get first 10 Credenciales
     * const credenciales = await prisma.credenciales.findMany({ take: 10 })
     * 
     * // Only select the `usuario`
     * const credencialesWithUsuarioOnly = await prisma.credenciales.findMany({ select: { usuario: true } })
     * 
    **/
    findMany<T extends credencialesFindManyArgs>(
      args?: SelectSubset<T, credencialesFindManyArgs>
    ): Prisma.PrismaPromise<Array<credencialesGetPayload<T>>>

    /**
     * Create a Credenciales.
     * @param {credencialesCreateArgs} args - Arguments to create a Credenciales.
     * @example
     * // Create one Credenciales
     * const Credenciales = await prisma.credenciales.create({
     *   data: {
     *     // ... data to create a Credenciales
     *   }
     * })
     * 
    **/
    create<T extends credencialesCreateArgs>(
      args: SelectSubset<T, credencialesCreateArgs>
    ): Prisma__credencialesClient<credencialesGetPayload<T>>

    /**
     * Create many Credenciales.
     *     @param {credencialesCreateManyArgs} args - Arguments to create many Credenciales.
     *     @example
     *     // Create many Credenciales
     *     const credenciales = await prisma.credenciales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends credencialesCreateManyArgs>(
      args?: SelectSubset<T, credencialesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Credenciales.
     * @param {credencialesDeleteArgs} args - Arguments to delete one Credenciales.
     * @example
     * // Delete one Credenciales
     * const Credenciales = await prisma.credenciales.delete({
     *   where: {
     *     // ... filter to delete one Credenciales
     *   }
     * })
     * 
    **/
    delete<T extends credencialesDeleteArgs>(
      args: SelectSubset<T, credencialesDeleteArgs>
    ): Prisma__credencialesClient<credencialesGetPayload<T>>

    /**
     * Update one Credenciales.
     * @param {credencialesUpdateArgs} args - Arguments to update one Credenciales.
     * @example
     * // Update one Credenciales
     * const credenciales = await prisma.credenciales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends credencialesUpdateArgs>(
      args: SelectSubset<T, credencialesUpdateArgs>
    ): Prisma__credencialesClient<credencialesGetPayload<T>>

    /**
     * Delete zero or more Credenciales.
     * @param {credencialesDeleteManyArgs} args - Arguments to filter Credenciales to delete.
     * @example
     * // Delete a few Credenciales
     * const { count } = await prisma.credenciales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends credencialesDeleteManyArgs>(
      args?: SelectSubset<T, credencialesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credenciales
     * const credenciales = await prisma.credenciales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends credencialesUpdateManyArgs>(
      args: SelectSubset<T, credencialesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credenciales.
     * @param {credencialesUpsertArgs} args - Arguments to update or create a Credenciales.
     * @example
     * // Update or create a Credenciales
     * const credenciales = await prisma.credenciales.upsert({
     *   create: {
     *     // ... data to create a Credenciales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credenciales we want to update
     *   }
     * })
    **/
    upsert<T extends credencialesUpsertArgs>(
      args: SelectSubset<T, credencialesUpsertArgs>
    ): Prisma__credencialesClient<credencialesGetPayload<T>>

    /**
     * Count the number of Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesCountArgs} args - Arguments to filter Credenciales to count.
     * @example
     * // Count the number of Credenciales
     * const count = await prisma.credenciales.count({
     *   where: {
     *     // ... the filter for the Credenciales we want to count
     *   }
     * })
    **/
    count<T extends credencialesCountArgs>(
      args?: Subset<T, credencialesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredencialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredencialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredencialesAggregateArgs>(args: Subset<T, CredencialesAggregateArgs>): Prisma.PrismaPromise<GetCredencialesAggregateType<T>>

    /**
     * Group by Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredencialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredencialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredencialesGroupByArgs['orderBy'] }
        : { orderBy?: CredencialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredencialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredencialesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for credenciales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__credencialesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuarios<T extends usuariosArgs= {}>(args?: Subset<T, usuariosArgs>): Prisma__usuariosClient<usuariosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * credenciales base type for findUnique actions
   */
  export type credencialesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * Filter, which credenciales to fetch.
     */
    where: credencialesWhereUniqueInput
  }

  /**
   * credenciales findUnique
   */
  export interface credencialesFindUniqueArgs extends credencialesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * credenciales findUniqueOrThrow
   */
  export type credencialesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * Filter, which credenciales to fetch.
     */
    where: credencialesWhereUniqueInput
  }


  /**
   * credenciales base type for findFirst actions
   */
  export type credencialesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * Filter, which credenciales to fetch.
     */
    where?: credencialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credenciales to fetch.
     */
    orderBy?: Enumerable<credencialesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credenciales.
     */
    cursor?: credencialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credenciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credenciales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credenciales.
     */
    distinct?: Enumerable<CredencialesScalarFieldEnum>
  }

  /**
   * credenciales findFirst
   */
  export interface credencialesFindFirstArgs extends credencialesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * credenciales findFirstOrThrow
   */
  export type credencialesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * Filter, which credenciales to fetch.
     */
    where?: credencialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credenciales to fetch.
     */
    orderBy?: Enumerable<credencialesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credenciales.
     */
    cursor?: credencialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credenciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credenciales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credenciales.
     */
    distinct?: Enumerable<CredencialesScalarFieldEnum>
  }


  /**
   * credenciales findMany
   */
  export type credencialesFindManyArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * Filter, which credenciales to fetch.
     */
    where?: credencialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credenciales to fetch.
     */
    orderBy?: Enumerable<credencialesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credenciales.
     */
    cursor?: credencialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credenciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credenciales.
     */
    skip?: number
    distinct?: Enumerable<CredencialesScalarFieldEnum>
  }


  /**
   * credenciales create
   */
  export type credencialesCreateArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * The data needed to create a credenciales.
     */
    data: XOR<credencialesCreateInput, credencialesUncheckedCreateInput>
  }


  /**
   * credenciales createMany
   */
  export type credencialesCreateManyArgs = {
    /**
     * The data used to create many credenciales.
     */
    data: Enumerable<credencialesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * credenciales update
   */
  export type credencialesUpdateArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * The data needed to update a credenciales.
     */
    data: XOR<credencialesUpdateInput, credencialesUncheckedUpdateInput>
    /**
     * Choose, which credenciales to update.
     */
    where: credencialesWhereUniqueInput
  }


  /**
   * credenciales updateMany
   */
  export type credencialesUpdateManyArgs = {
    /**
     * The data used to update credenciales.
     */
    data: XOR<credencialesUpdateManyMutationInput, credencialesUncheckedUpdateManyInput>
    /**
     * Filter which credenciales to update
     */
    where?: credencialesWhereInput
  }


  /**
   * credenciales upsert
   */
  export type credencialesUpsertArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * The filter to search for the credenciales to update in case it exists.
     */
    where: credencialesWhereUniqueInput
    /**
     * In case the credenciales found by the `where` argument doesn't exist, create a new credenciales with this data.
     */
    create: XOR<credencialesCreateInput, credencialesUncheckedCreateInput>
    /**
     * In case the credenciales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credencialesUpdateInput, credencialesUncheckedUpdateInput>
  }


  /**
   * credenciales delete
   */
  export type credencialesDeleteArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
    /**
     * Filter which credenciales to delete.
     */
    where: credencialesWhereUniqueInput
  }


  /**
   * credenciales deleteMany
   */
  export type credencialesDeleteManyArgs = {
    /**
     * Filter which credenciales to delete
     */
    where?: credencialesWhereInput
  }


  /**
   * credenciales without action
   */
  export type credencialesArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     */
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credencialesInclude | null
  }



  /**
   * Model estudiantes
   */


  export type AggregateEstudiantes = {
    _count: EstudiantesCountAggregateOutputType | null
    _avg: EstudiantesAvgAggregateOutputType | null
    _sum: EstudiantesSumAggregateOutputType | null
    _min: EstudiantesMinAggregateOutputType | null
    _max: EstudiantesMaxAggregateOutputType | null
  }

  export type EstudiantesAvgAggregateOutputType = {
    codigo: number | null
  }

  export type EstudiantesSumAggregateOutputType = {
    codigo: number | null
  }

  export type EstudiantesMinAggregateOutputType = {
    codigo: number | null
    nombre: string | null
    apellido: string | null
    tipo_documento: string | null
    numero_documento: string | null
    estado: string | null
    genero: string | null
    path: string | null
  }

  export type EstudiantesMaxAggregateOutputType = {
    codigo: number | null
    nombre: string | null
    apellido: string | null
    tipo_documento: string | null
    numero_documento: string | null
    estado: string | null
    genero: string | null
    path: string | null
  }

  export type EstudiantesCountAggregateOutputType = {
    codigo: number
    nombre: number
    apellido: number
    tipo_documento: number
    numero_documento: number
    estado: number
    genero: number
    path: number
    _all: number
  }


  export type EstudiantesAvgAggregateInputType = {
    codigo?: true
  }

  export type EstudiantesSumAggregateInputType = {
    codigo?: true
  }

  export type EstudiantesMinAggregateInputType = {
    codigo?: true
    nombre?: true
    apellido?: true
    tipo_documento?: true
    numero_documento?: true
    estado?: true
    genero?: true
    path?: true
  }

  export type EstudiantesMaxAggregateInputType = {
    codigo?: true
    nombre?: true
    apellido?: true
    tipo_documento?: true
    numero_documento?: true
    estado?: true
    genero?: true
    path?: true
  }

  export type EstudiantesCountAggregateInputType = {
    codigo?: true
    nombre?: true
    apellido?: true
    tipo_documento?: true
    numero_documento?: true
    estado?: true
    genero?: true
    path?: true
    _all?: true
  }

  export type EstudiantesAggregateArgs = {
    /**
     * Filter which estudiantes to aggregate.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: Enumerable<estudiantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estudiantes
    **/
    _count?: true | EstudiantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudiantesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudiantesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudiantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudiantesMaxAggregateInputType
  }

  export type GetEstudiantesAggregateType<T extends EstudiantesAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiantes[P]>
      : GetScalarType<T[P], AggregateEstudiantes[P]>
  }




  export type EstudiantesGroupByArgs = {
    where?: estudiantesWhereInput
    orderBy?: Enumerable<estudiantesOrderByWithAggregationInput>
    by: EstudiantesScalarFieldEnum[]
    having?: estudiantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudiantesCountAggregateInputType | true
    _avg?: EstudiantesAvgAggregateInputType
    _sum?: EstudiantesSumAggregateInputType
    _min?: EstudiantesMinAggregateInputType
    _max?: EstudiantesMaxAggregateInputType
  }


  export type EstudiantesGroupByOutputType = {
    codigo: number
    nombre: string
    apellido: string
    tipo_documento: string
    numero_documento: string
    estado: string | null
    genero: string | null
    path: string
    _count: EstudiantesCountAggregateOutputType | null
    _avg: EstudiantesAvgAggregateOutputType | null
    _sum: EstudiantesSumAggregateOutputType | null
    _min: EstudiantesMinAggregateOutputType | null
    _max: EstudiantesMaxAggregateOutputType | null
  }

  type GetEstudiantesGroupByPayload<T extends EstudiantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EstudiantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudiantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudiantesGroupByOutputType[P]>
            : GetScalarType<T[P], EstudiantesGroupByOutputType[P]>
        }
      >
    >


  export type estudiantesSelect = {
    codigo?: boolean
    nombre?: boolean
    apellido?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    estado?: boolean
    genero?: boolean
    path?: boolean
    inscripciones?: boolean | estudiantes$inscripcionesArgs
    _count?: boolean | EstudiantesCountOutputTypeArgs
  }


  export type estudiantesInclude = {
    inscripciones?: boolean | estudiantes$inscripcionesArgs
    _count?: boolean | EstudiantesCountOutputTypeArgs
  }

  export type estudiantesGetPayload<S extends boolean | null | undefined | estudiantesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? estudiantes :
    S extends undefined ? never :
    S extends { include: any } & (estudiantesArgs | estudiantesFindManyArgs)
    ? estudiantes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'inscripciones' ? Array < inscripcionesGetPayload<S['include'][P]>>  :
        P extends '_count' ? EstudiantesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (estudiantesArgs | estudiantesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'inscripciones' ? Array < inscripcionesGetPayload<S['select'][P]>>  :
        P extends '_count' ? EstudiantesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof estudiantes ? estudiantes[P] : never
  } 
      : estudiantes


  type estudiantesCountArgs = 
    Omit<estudiantesFindManyArgs, 'select' | 'include'> & {
      select?: EstudiantesCountAggregateInputType | true
    }

  export interface estudiantesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Estudiantes that matches the filter.
     * @param {estudiantesFindUniqueArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends estudiantesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, estudiantesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'estudiantes'> extends True ? Prisma__estudiantesClient<estudiantesGetPayload<T>> : Prisma__estudiantesClient<estudiantesGetPayload<T> | null, null>

    /**
     * Find one Estudiantes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {estudiantesFindUniqueOrThrowArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends estudiantesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, estudiantesFindUniqueOrThrowArgs>
    ): Prisma__estudiantesClient<estudiantesGetPayload<T>>

    /**
     * Find the first Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindFirstArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends estudiantesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, estudiantesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'estudiantes'> extends True ? Prisma__estudiantesClient<estudiantesGetPayload<T>> : Prisma__estudiantesClient<estudiantesGetPayload<T> | null, null>

    /**
     * Find the first Estudiantes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindFirstOrThrowArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends estudiantesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, estudiantesFindFirstOrThrowArgs>
    ): Prisma__estudiantesClient<estudiantesGetPayload<T>>

    /**
     * Find zero or more Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudiantes
     * const estudiantes = await prisma.estudiantes.findMany()
     * 
     * // Get first 10 Estudiantes
     * const estudiantes = await prisma.estudiantes.findMany({ take: 10 })
     * 
     * // Only select the `codigo`
     * const estudiantesWithCodigoOnly = await prisma.estudiantes.findMany({ select: { codigo: true } })
     * 
    **/
    findMany<T extends estudiantesFindManyArgs>(
      args?: SelectSubset<T, estudiantesFindManyArgs>
    ): Prisma.PrismaPromise<Array<estudiantesGetPayload<T>>>

    /**
     * Create a Estudiantes.
     * @param {estudiantesCreateArgs} args - Arguments to create a Estudiantes.
     * @example
     * // Create one Estudiantes
     * const Estudiantes = await prisma.estudiantes.create({
     *   data: {
     *     // ... data to create a Estudiantes
     *   }
     * })
     * 
    **/
    create<T extends estudiantesCreateArgs>(
      args: SelectSubset<T, estudiantesCreateArgs>
    ): Prisma__estudiantesClient<estudiantesGetPayload<T>>

    /**
     * Create many Estudiantes.
     *     @param {estudiantesCreateManyArgs} args - Arguments to create many Estudiantes.
     *     @example
     *     // Create many Estudiantes
     *     const estudiantes = await prisma.estudiantes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends estudiantesCreateManyArgs>(
      args?: SelectSubset<T, estudiantesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estudiantes.
     * @param {estudiantesDeleteArgs} args - Arguments to delete one Estudiantes.
     * @example
     * // Delete one Estudiantes
     * const Estudiantes = await prisma.estudiantes.delete({
     *   where: {
     *     // ... filter to delete one Estudiantes
     *   }
     * })
     * 
    **/
    delete<T extends estudiantesDeleteArgs>(
      args: SelectSubset<T, estudiantesDeleteArgs>
    ): Prisma__estudiantesClient<estudiantesGetPayload<T>>

    /**
     * Update one Estudiantes.
     * @param {estudiantesUpdateArgs} args - Arguments to update one Estudiantes.
     * @example
     * // Update one Estudiantes
     * const estudiantes = await prisma.estudiantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends estudiantesUpdateArgs>(
      args: SelectSubset<T, estudiantesUpdateArgs>
    ): Prisma__estudiantesClient<estudiantesGetPayload<T>>

    /**
     * Delete zero or more Estudiantes.
     * @param {estudiantesDeleteManyArgs} args - Arguments to filter Estudiantes to delete.
     * @example
     * // Delete a few Estudiantes
     * const { count } = await prisma.estudiantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends estudiantesDeleteManyArgs>(
      args?: SelectSubset<T, estudiantesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudiantes
     * const estudiantes = await prisma.estudiantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends estudiantesUpdateManyArgs>(
      args: SelectSubset<T, estudiantesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estudiantes.
     * @param {estudiantesUpsertArgs} args - Arguments to update or create a Estudiantes.
     * @example
     * // Update or create a Estudiantes
     * const estudiantes = await prisma.estudiantes.upsert({
     *   create: {
     *     // ... data to create a Estudiantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudiantes we want to update
     *   }
     * })
    **/
    upsert<T extends estudiantesUpsertArgs>(
      args: SelectSubset<T, estudiantesUpsertArgs>
    ): Prisma__estudiantesClient<estudiantesGetPayload<T>>

    /**
     * Count the number of Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesCountArgs} args - Arguments to filter Estudiantes to count.
     * @example
     * // Count the number of Estudiantes
     * const count = await prisma.estudiantes.count({
     *   where: {
     *     // ... the filter for the Estudiantes we want to count
     *   }
     * })
    **/
    count<T extends estudiantesCountArgs>(
      args?: Subset<T, estudiantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudiantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudiantesAggregateArgs>(args: Subset<T, EstudiantesAggregateArgs>): Prisma.PrismaPromise<GetEstudiantesAggregateType<T>>

    /**
     * Group by Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudiantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudiantesGroupByArgs['orderBy'] }
        : { orderBy?: EstudiantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudiantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudiantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for estudiantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__estudiantesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    inscripciones<T extends estudiantes$inscripcionesArgs= {}>(args?: Subset<T, estudiantes$inscripcionesArgs>): Prisma.PrismaPromise<Array<inscripcionesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * estudiantes base type for findUnique actions
   */
  export type estudiantesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes findUnique
   */
  export interface estudiantesFindUniqueArgs extends estudiantesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * estudiantes findUniqueOrThrow
   */
  export type estudiantesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where: estudiantesWhereUniqueInput
  }


  /**
   * estudiantes base type for findFirst actions
   */
  export type estudiantesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: Enumerable<estudiantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estudiantes.
     */
    distinct?: Enumerable<EstudiantesScalarFieldEnum>
  }

  /**
   * estudiantes findFirst
   */
  export interface estudiantesFindFirstArgs extends estudiantesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * estudiantes findFirstOrThrow
   */
  export type estudiantesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: Enumerable<estudiantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estudiantes.
     */
    distinct?: Enumerable<EstudiantesScalarFieldEnum>
  }


  /**
   * estudiantes findMany
   */
  export type estudiantesFindManyArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: Enumerable<estudiantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    distinct?: Enumerable<EstudiantesScalarFieldEnum>
  }


  /**
   * estudiantes create
   */
  export type estudiantesCreateArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * The data needed to create a estudiantes.
     */
    data: XOR<estudiantesCreateInput, estudiantesUncheckedCreateInput>
  }


  /**
   * estudiantes createMany
   */
  export type estudiantesCreateManyArgs = {
    /**
     * The data used to create many estudiantes.
     */
    data: Enumerable<estudiantesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * estudiantes update
   */
  export type estudiantesUpdateArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * The data needed to update a estudiantes.
     */
    data: XOR<estudiantesUpdateInput, estudiantesUncheckedUpdateInput>
    /**
     * Choose, which estudiantes to update.
     */
    where: estudiantesWhereUniqueInput
  }


  /**
   * estudiantes updateMany
   */
  export type estudiantesUpdateManyArgs = {
    /**
     * The data used to update estudiantes.
     */
    data: XOR<estudiantesUpdateManyMutationInput, estudiantesUncheckedUpdateManyInput>
    /**
     * Filter which estudiantes to update
     */
    where?: estudiantesWhereInput
  }


  /**
   * estudiantes upsert
   */
  export type estudiantesUpsertArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * The filter to search for the estudiantes to update in case it exists.
     */
    where: estudiantesWhereUniqueInput
    /**
     * In case the estudiantes found by the `where` argument doesn't exist, create a new estudiantes with this data.
     */
    create: XOR<estudiantesCreateInput, estudiantesUncheckedCreateInput>
    /**
     * In case the estudiantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estudiantesUpdateInput, estudiantesUncheckedUpdateInput>
  }


  /**
   * estudiantes delete
   */
  export type estudiantesDeleteArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
    /**
     * Filter which estudiantes to delete.
     */
    where: estudiantesWhereUniqueInput
  }


  /**
   * estudiantes deleteMany
   */
  export type estudiantesDeleteManyArgs = {
    /**
     * Filter which estudiantes to delete
     */
    where?: estudiantesWhereInput
  }


  /**
   * estudiantes.inscripciones
   */
  export type estudiantes$inscripcionesArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    where?: inscripcionesWhereInput
    orderBy?: Enumerable<inscripcionesOrderByWithRelationInput>
    cursor?: inscripcionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InscripcionesScalarFieldEnum>
  }


  /**
   * estudiantes without action
   */
  export type estudiantesArgs = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: estudiantesInclude | null
  }



  /**
   * Model inscripciones
   */


  export type AggregateInscripciones = {
    _count: InscripcionesCountAggregateOutputType | null
    _avg: InscripcionesAvgAggregateOutputType | null
    _sum: InscripcionesSumAggregateOutputType | null
    _min: InscripcionesMinAggregateOutputType | null
    _max: InscripcionesMaxAggregateOutputType | null
  }

  export type InscripcionesAvgAggregateOutputType = {
    id_inscripcion: number | null
    codigo_estudiante: number | null
    codigo_materia: number | null
  }

  export type InscripcionesSumAggregateOutputType = {
    id_inscripcion: number | null
    codigo_estudiante: number | null
    codigo_materia: number | null
  }

  export type InscripcionesMinAggregateOutputType = {
    id_inscripcion: number | null
    codigo_estudiante: number | null
    codigo_materia: number | null
    fecha_inscripcion: Date | null
  }

  export type InscripcionesMaxAggregateOutputType = {
    id_inscripcion: number | null
    codigo_estudiante: number | null
    codigo_materia: number | null
    fecha_inscripcion: Date | null
  }

  export type InscripcionesCountAggregateOutputType = {
    id_inscripcion: number
    codigo_estudiante: number
    codigo_materia: number
    fecha_inscripcion: number
    _all: number
  }


  export type InscripcionesAvgAggregateInputType = {
    id_inscripcion?: true
    codigo_estudiante?: true
    codigo_materia?: true
  }

  export type InscripcionesSumAggregateInputType = {
    id_inscripcion?: true
    codigo_estudiante?: true
    codigo_materia?: true
  }

  export type InscripcionesMinAggregateInputType = {
    id_inscripcion?: true
    codigo_estudiante?: true
    codigo_materia?: true
    fecha_inscripcion?: true
  }

  export type InscripcionesMaxAggregateInputType = {
    id_inscripcion?: true
    codigo_estudiante?: true
    codigo_materia?: true
    fecha_inscripcion?: true
  }

  export type InscripcionesCountAggregateInputType = {
    id_inscripcion?: true
    codigo_estudiante?: true
    codigo_materia?: true
    fecha_inscripcion?: true
    _all?: true
  }

  export type InscripcionesAggregateArgs = {
    /**
     * Filter which inscripciones to aggregate.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: Enumerable<inscripcionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inscripciones
    **/
    _count?: true | InscripcionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InscripcionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InscripcionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscripcionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscripcionesMaxAggregateInputType
  }

  export type GetInscripcionesAggregateType<T extends InscripcionesAggregateArgs> = {
        [P in keyof T & keyof AggregateInscripciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscripciones[P]>
      : GetScalarType<T[P], AggregateInscripciones[P]>
  }




  export type InscripcionesGroupByArgs = {
    where?: inscripcionesWhereInput
    orderBy?: Enumerable<inscripcionesOrderByWithAggregationInput>
    by: InscripcionesScalarFieldEnum[]
    having?: inscripcionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscripcionesCountAggregateInputType | true
    _avg?: InscripcionesAvgAggregateInputType
    _sum?: InscripcionesSumAggregateInputType
    _min?: InscripcionesMinAggregateInputType
    _max?: InscripcionesMaxAggregateInputType
  }


  export type InscripcionesGroupByOutputType = {
    id_inscripcion: number
    codigo_estudiante: number
    codigo_materia: number
    fecha_inscripcion: Date
    _count: InscripcionesCountAggregateOutputType | null
    _avg: InscripcionesAvgAggregateOutputType | null
    _sum: InscripcionesSumAggregateOutputType | null
    _min: InscripcionesMinAggregateOutputType | null
    _max: InscripcionesMaxAggregateOutputType | null
  }

  type GetInscripcionesGroupByPayload<T extends InscripcionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InscripcionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscripcionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscripcionesGroupByOutputType[P]>
            : GetScalarType<T[P], InscripcionesGroupByOutputType[P]>
        }
      >
    >


  export type inscripcionesSelect = {
    id_inscripcion?: boolean
    codigo_estudiante?: boolean
    codigo_materia?: boolean
    fecha_inscripcion?: boolean
    estudiantes?: boolean | estudiantesArgs
    materias?: boolean | materiasArgs
  }


  export type inscripcionesInclude = {
    estudiantes?: boolean | estudiantesArgs
    materias?: boolean | materiasArgs
  }

  export type inscripcionesGetPayload<S extends boolean | null | undefined | inscripcionesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? inscripciones :
    S extends undefined ? never :
    S extends { include: any } & (inscripcionesArgs | inscripcionesFindManyArgs)
    ? inscripciones  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'estudiantes' ? estudiantesGetPayload<S['include'][P]> :
        P extends 'materias' ? materiasGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (inscripcionesArgs | inscripcionesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'estudiantes' ? estudiantesGetPayload<S['select'][P]> :
        P extends 'materias' ? materiasGetPayload<S['select'][P]> :  P extends keyof inscripciones ? inscripciones[P] : never
  } 
      : inscripciones


  type inscripcionesCountArgs = 
    Omit<inscripcionesFindManyArgs, 'select' | 'include'> & {
      select?: InscripcionesCountAggregateInputType | true
    }

  export interface inscripcionesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Inscripciones that matches the filter.
     * @param {inscripcionesFindUniqueArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inscripcionesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, inscripcionesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'inscripciones'> extends True ? Prisma__inscripcionesClient<inscripcionesGetPayload<T>> : Prisma__inscripcionesClient<inscripcionesGetPayload<T> | null, null>

    /**
     * Find one Inscripciones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inscripcionesFindUniqueOrThrowArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inscripcionesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, inscripcionesFindUniqueOrThrowArgs>
    ): Prisma__inscripcionesClient<inscripcionesGetPayload<T>>

    /**
     * Find the first Inscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindFirstArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inscripcionesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, inscripcionesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'inscripciones'> extends True ? Prisma__inscripcionesClient<inscripcionesGetPayload<T>> : Prisma__inscripcionesClient<inscripcionesGetPayload<T> | null, null>

    /**
     * Find the first Inscripciones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindFirstOrThrowArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inscripcionesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, inscripcionesFindFirstOrThrowArgs>
    ): Prisma__inscripcionesClient<inscripcionesGetPayload<T>>

    /**
     * Find zero or more Inscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscripciones
     * const inscripciones = await prisma.inscripciones.findMany()
     * 
     * // Get first 10 Inscripciones
     * const inscripciones = await prisma.inscripciones.findMany({ take: 10 })
     * 
     * // Only select the `id_inscripcion`
     * const inscripcionesWithId_inscripcionOnly = await prisma.inscripciones.findMany({ select: { id_inscripcion: true } })
     * 
    **/
    findMany<T extends inscripcionesFindManyArgs>(
      args?: SelectSubset<T, inscripcionesFindManyArgs>
    ): Prisma.PrismaPromise<Array<inscripcionesGetPayload<T>>>

    /**
     * Create a Inscripciones.
     * @param {inscripcionesCreateArgs} args - Arguments to create a Inscripciones.
     * @example
     * // Create one Inscripciones
     * const Inscripciones = await prisma.inscripciones.create({
     *   data: {
     *     // ... data to create a Inscripciones
     *   }
     * })
     * 
    **/
    create<T extends inscripcionesCreateArgs>(
      args: SelectSubset<T, inscripcionesCreateArgs>
    ): Prisma__inscripcionesClient<inscripcionesGetPayload<T>>

    /**
     * Create many Inscripciones.
     *     @param {inscripcionesCreateManyArgs} args - Arguments to create many Inscripciones.
     *     @example
     *     // Create many Inscripciones
     *     const inscripciones = await prisma.inscripciones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inscripcionesCreateManyArgs>(
      args?: SelectSubset<T, inscripcionesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inscripciones.
     * @param {inscripcionesDeleteArgs} args - Arguments to delete one Inscripciones.
     * @example
     * // Delete one Inscripciones
     * const Inscripciones = await prisma.inscripciones.delete({
     *   where: {
     *     // ... filter to delete one Inscripciones
     *   }
     * })
     * 
    **/
    delete<T extends inscripcionesDeleteArgs>(
      args: SelectSubset<T, inscripcionesDeleteArgs>
    ): Prisma__inscripcionesClient<inscripcionesGetPayload<T>>

    /**
     * Update one Inscripciones.
     * @param {inscripcionesUpdateArgs} args - Arguments to update one Inscripciones.
     * @example
     * // Update one Inscripciones
     * const inscripciones = await prisma.inscripciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inscripcionesUpdateArgs>(
      args: SelectSubset<T, inscripcionesUpdateArgs>
    ): Prisma__inscripcionesClient<inscripcionesGetPayload<T>>

    /**
     * Delete zero or more Inscripciones.
     * @param {inscripcionesDeleteManyArgs} args - Arguments to filter Inscripciones to delete.
     * @example
     * // Delete a few Inscripciones
     * const { count } = await prisma.inscripciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inscripcionesDeleteManyArgs>(
      args?: SelectSubset<T, inscripcionesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscripciones
     * const inscripciones = await prisma.inscripciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inscripcionesUpdateManyArgs>(
      args: SelectSubset<T, inscripcionesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inscripciones.
     * @param {inscripcionesUpsertArgs} args - Arguments to update or create a Inscripciones.
     * @example
     * // Update or create a Inscripciones
     * const inscripciones = await prisma.inscripciones.upsert({
     *   create: {
     *     // ... data to create a Inscripciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscripciones we want to update
     *   }
     * })
    **/
    upsert<T extends inscripcionesUpsertArgs>(
      args: SelectSubset<T, inscripcionesUpsertArgs>
    ): Prisma__inscripcionesClient<inscripcionesGetPayload<T>>

    /**
     * Count the number of Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesCountArgs} args - Arguments to filter Inscripciones to count.
     * @example
     * // Count the number of Inscripciones
     * const count = await prisma.inscripciones.count({
     *   where: {
     *     // ... the filter for the Inscripciones we want to count
     *   }
     * })
    **/
    count<T extends inscripcionesCountArgs>(
      args?: Subset<T, inscripcionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscripcionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscripcionesAggregateArgs>(args: Subset<T, InscripcionesAggregateArgs>): Prisma.PrismaPromise<GetInscripcionesAggregateType<T>>

    /**
     * Group by Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InscripcionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InscripcionesGroupByArgs['orderBy'] }
        : { orderBy?: InscripcionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InscripcionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscripcionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for inscripciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__inscripcionesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    estudiantes<T extends estudiantesArgs= {}>(args?: Subset<T, estudiantesArgs>): Prisma__estudiantesClient<estudiantesGetPayload<T> | Null>;

    materias<T extends materiasArgs= {}>(args?: Subset<T, materiasArgs>): Prisma__materiasClient<materiasGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * inscripciones base type for findUnique actions
   */
  export type inscripcionesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones findUnique
   */
  export interface inscripcionesFindUniqueArgs extends inscripcionesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inscripciones findUniqueOrThrow
   */
  export type inscripcionesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where: inscripcionesWhereUniqueInput
  }


  /**
   * inscripciones base type for findFirst actions
   */
  export type inscripcionesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: Enumerable<inscripcionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscripciones.
     */
    distinct?: Enumerable<InscripcionesScalarFieldEnum>
  }

  /**
   * inscripciones findFirst
   */
  export interface inscripcionesFindFirstArgs extends inscripcionesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inscripciones findFirstOrThrow
   */
  export type inscripcionesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: Enumerable<inscripcionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscripciones.
     */
    distinct?: Enumerable<InscripcionesScalarFieldEnum>
  }


  /**
   * inscripciones findMany
   */
  export type inscripcionesFindManyArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: Enumerable<inscripcionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    distinct?: Enumerable<InscripcionesScalarFieldEnum>
  }


  /**
   * inscripciones create
   */
  export type inscripcionesCreateArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * The data needed to create a inscripciones.
     */
    data: XOR<inscripcionesCreateInput, inscripcionesUncheckedCreateInput>
  }


  /**
   * inscripciones createMany
   */
  export type inscripcionesCreateManyArgs = {
    /**
     * The data used to create many inscripciones.
     */
    data: Enumerable<inscripcionesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * inscripciones update
   */
  export type inscripcionesUpdateArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * The data needed to update a inscripciones.
     */
    data: XOR<inscripcionesUpdateInput, inscripcionesUncheckedUpdateInput>
    /**
     * Choose, which inscripciones to update.
     */
    where: inscripcionesWhereUniqueInput
  }


  /**
   * inscripciones updateMany
   */
  export type inscripcionesUpdateManyArgs = {
    /**
     * The data used to update inscripciones.
     */
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyInput>
    /**
     * Filter which inscripciones to update
     */
    where?: inscripcionesWhereInput
  }


  /**
   * inscripciones upsert
   */
  export type inscripcionesUpsertArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * The filter to search for the inscripciones to update in case it exists.
     */
    where: inscripcionesWhereUniqueInput
    /**
     * In case the inscripciones found by the `where` argument doesn't exist, create a new inscripciones with this data.
     */
    create: XOR<inscripcionesCreateInput, inscripcionesUncheckedCreateInput>
    /**
     * In case the inscripciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inscripcionesUpdateInput, inscripcionesUncheckedUpdateInput>
  }


  /**
   * inscripciones delete
   */
  export type inscripcionesDeleteArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    /**
     * Filter which inscripciones to delete.
     */
    where: inscripcionesWhereUniqueInput
  }


  /**
   * inscripciones deleteMany
   */
  export type inscripcionesDeleteManyArgs = {
    /**
     * Filter which inscripciones to delete
     */
    where?: inscripcionesWhereInput
  }


  /**
   * inscripciones without action
   */
  export type inscripcionesArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
  }



  /**
   * Model materias
   */


  export type AggregateMaterias = {
    _count: MateriasCountAggregateOutputType | null
    _avg: MateriasAvgAggregateOutputType | null
    _sum: MateriasSumAggregateOutputType | null
    _min: MateriasMinAggregateOutputType | null
    _max: MateriasMaxAggregateOutputType | null
  }

  export type MateriasAvgAggregateOutputType = {
    codigo: number | null
    cupos: number | null
  }

  export type MateriasSumAggregateOutputType = {
    codigo: number | null
    cupos: number | null
  }

  export type MateriasMinAggregateOutputType = {
    codigo: number | null
    nombre: string | null
    cupos: number | null
    estado: string | null
  }

  export type MateriasMaxAggregateOutputType = {
    codigo: number | null
    nombre: string | null
    cupos: number | null
    estado: string | null
  }

  export type MateriasCountAggregateOutputType = {
    codigo: number
    nombre: number
    cupos: number
    estado: number
    _all: number
  }


  export type MateriasAvgAggregateInputType = {
    codigo?: true
    cupos?: true
  }

  export type MateriasSumAggregateInputType = {
    codigo?: true
    cupos?: true
  }

  export type MateriasMinAggregateInputType = {
    codigo?: true
    nombre?: true
    cupos?: true
    estado?: true
  }

  export type MateriasMaxAggregateInputType = {
    codigo?: true
    nombre?: true
    cupos?: true
    estado?: true
  }

  export type MateriasCountAggregateInputType = {
    codigo?: true
    nombre?: true
    cupos?: true
    estado?: true
    _all?: true
  }

  export type MateriasAggregateArgs = {
    /**
     * Filter which materias to aggregate.
     */
    where?: materiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: materiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materias
    **/
    _count?: true | MateriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MateriasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MateriasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MateriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MateriasMaxAggregateInputType
  }

  export type GetMateriasAggregateType<T extends MateriasAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterias[P]>
      : GetScalarType<T[P], AggregateMaterias[P]>
  }




  export type MateriasGroupByArgs = {
    where?: materiasWhereInput
    orderBy?: Enumerable<materiasOrderByWithAggregationInput>
    by: MateriasScalarFieldEnum[]
    having?: materiasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MateriasCountAggregateInputType | true
    _avg?: MateriasAvgAggregateInputType
    _sum?: MateriasSumAggregateInputType
    _min?: MateriasMinAggregateInputType
    _max?: MateriasMaxAggregateInputType
  }


  export type MateriasGroupByOutputType = {
    codigo: number
    nombre: string
    cupos: number | null
    estado: string | null
    _count: MateriasCountAggregateOutputType | null
    _avg: MateriasAvgAggregateOutputType | null
    _sum: MateriasSumAggregateOutputType | null
    _min: MateriasMinAggregateOutputType | null
    _max: MateriasMaxAggregateOutputType | null
  }

  type GetMateriasGroupByPayload<T extends MateriasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MateriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MateriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MateriasGroupByOutputType[P]>
            : GetScalarType<T[P], MateriasGroupByOutputType[P]>
        }
      >
    >


  export type materiasSelect = {
    codigo?: boolean
    nombre?: boolean
    cupos?: boolean
    estado?: boolean
    inscripciones?: boolean | materias$inscripcionesArgs
    _count?: boolean | MateriasCountOutputTypeArgs
  }


  export type materiasInclude = {
    inscripciones?: boolean | materias$inscripcionesArgs
    _count?: boolean | MateriasCountOutputTypeArgs
  }

  export type materiasGetPayload<S extends boolean | null | undefined | materiasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? materias :
    S extends undefined ? never :
    S extends { include: any } & (materiasArgs | materiasFindManyArgs)
    ? materias  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'inscripciones' ? Array < inscripcionesGetPayload<S['include'][P]>>  :
        P extends '_count' ? MateriasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (materiasArgs | materiasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'inscripciones' ? Array < inscripcionesGetPayload<S['select'][P]>>  :
        P extends '_count' ? MateriasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof materias ? materias[P] : never
  } 
      : materias


  type materiasCountArgs = 
    Omit<materiasFindManyArgs, 'select' | 'include'> & {
      select?: MateriasCountAggregateInputType | true
    }

  export interface materiasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Materias that matches the filter.
     * @param {materiasFindUniqueArgs} args - Arguments to find a Materias
     * @example
     * // Get one Materias
     * const materias = await prisma.materias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends materiasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, materiasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'materias'> extends True ? Prisma__materiasClient<materiasGetPayload<T>> : Prisma__materiasClient<materiasGetPayload<T> | null, null>

    /**
     * Find one Materias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {materiasFindUniqueOrThrowArgs} args - Arguments to find a Materias
     * @example
     * // Get one Materias
     * const materias = await prisma.materias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends materiasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, materiasFindUniqueOrThrowArgs>
    ): Prisma__materiasClient<materiasGetPayload<T>>

    /**
     * Find the first Materias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiasFindFirstArgs} args - Arguments to find a Materias
     * @example
     * // Get one Materias
     * const materias = await prisma.materias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends materiasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, materiasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'materias'> extends True ? Prisma__materiasClient<materiasGetPayload<T>> : Prisma__materiasClient<materiasGetPayload<T> | null, null>

    /**
     * Find the first Materias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiasFindFirstOrThrowArgs} args - Arguments to find a Materias
     * @example
     * // Get one Materias
     * const materias = await prisma.materias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends materiasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, materiasFindFirstOrThrowArgs>
    ): Prisma__materiasClient<materiasGetPayload<T>>

    /**
     * Find zero or more Materias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materias
     * const materias = await prisma.materias.findMany()
     * 
     * // Get first 10 Materias
     * const materias = await prisma.materias.findMany({ take: 10 })
     * 
     * // Only select the `codigo`
     * const materiasWithCodigoOnly = await prisma.materias.findMany({ select: { codigo: true } })
     * 
    **/
    findMany<T extends materiasFindManyArgs>(
      args?: SelectSubset<T, materiasFindManyArgs>
    ): Prisma.PrismaPromise<Array<materiasGetPayload<T>>>

    /**
     * Create a Materias.
     * @param {materiasCreateArgs} args - Arguments to create a Materias.
     * @example
     * // Create one Materias
     * const Materias = await prisma.materias.create({
     *   data: {
     *     // ... data to create a Materias
     *   }
     * })
     * 
    **/
    create<T extends materiasCreateArgs>(
      args: SelectSubset<T, materiasCreateArgs>
    ): Prisma__materiasClient<materiasGetPayload<T>>

    /**
     * Create many Materias.
     *     @param {materiasCreateManyArgs} args - Arguments to create many Materias.
     *     @example
     *     // Create many Materias
     *     const materias = await prisma.materias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends materiasCreateManyArgs>(
      args?: SelectSubset<T, materiasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materias.
     * @param {materiasDeleteArgs} args - Arguments to delete one Materias.
     * @example
     * // Delete one Materias
     * const Materias = await prisma.materias.delete({
     *   where: {
     *     // ... filter to delete one Materias
     *   }
     * })
     * 
    **/
    delete<T extends materiasDeleteArgs>(
      args: SelectSubset<T, materiasDeleteArgs>
    ): Prisma__materiasClient<materiasGetPayload<T>>

    /**
     * Update one Materias.
     * @param {materiasUpdateArgs} args - Arguments to update one Materias.
     * @example
     * // Update one Materias
     * const materias = await prisma.materias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends materiasUpdateArgs>(
      args: SelectSubset<T, materiasUpdateArgs>
    ): Prisma__materiasClient<materiasGetPayload<T>>

    /**
     * Delete zero or more Materias.
     * @param {materiasDeleteManyArgs} args - Arguments to filter Materias to delete.
     * @example
     * // Delete a few Materias
     * const { count } = await prisma.materias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends materiasDeleteManyArgs>(
      args?: SelectSubset<T, materiasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materias
     * const materias = await prisma.materias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends materiasUpdateManyArgs>(
      args: SelectSubset<T, materiasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materias.
     * @param {materiasUpsertArgs} args - Arguments to update or create a Materias.
     * @example
     * // Update or create a Materias
     * const materias = await prisma.materias.upsert({
     *   create: {
     *     // ... data to create a Materias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materias we want to update
     *   }
     * })
    **/
    upsert<T extends materiasUpsertArgs>(
      args: SelectSubset<T, materiasUpsertArgs>
    ): Prisma__materiasClient<materiasGetPayload<T>>

    /**
     * Count the number of Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materiasCountArgs} args - Arguments to filter Materias to count.
     * @example
     * // Count the number of Materias
     * const count = await prisma.materias.count({
     *   where: {
     *     // ... the filter for the Materias we want to count
     *   }
     * })
    **/
    count<T extends materiasCountArgs>(
      args?: Subset<T, materiasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MateriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MateriasAggregateArgs>(args: Subset<T, MateriasAggregateArgs>): Prisma.PrismaPromise<GetMateriasAggregateType<T>>

    /**
     * Group by Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MateriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MateriasGroupByArgs['orderBy'] }
        : { orderBy?: MateriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MateriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMateriasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for materias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__materiasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    inscripciones<T extends materias$inscripcionesArgs= {}>(args?: Subset<T, materias$inscripcionesArgs>): Prisma.PrismaPromise<Array<inscripcionesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * materias base type for findUnique actions
   */
  export type materiasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * Filter, which materias to fetch.
     */
    where: materiasWhereUniqueInput
  }

  /**
   * materias findUnique
   */
  export interface materiasFindUniqueArgs extends materiasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * materias findUniqueOrThrow
   */
  export type materiasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * Filter, which materias to fetch.
     */
    where: materiasWhereUniqueInput
  }


  /**
   * materias base type for findFirst actions
   */
  export type materiasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * Filter, which materias to fetch.
     */
    where?: materiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materias.
     */
    cursor?: materiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materias.
     */
    distinct?: Enumerable<MateriasScalarFieldEnum>
  }

  /**
   * materias findFirst
   */
  export interface materiasFindFirstArgs extends materiasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * materias findFirstOrThrow
   */
  export type materiasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * Filter, which materias to fetch.
     */
    where?: materiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materias.
     */
    cursor?: materiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materias.
     */
    distinct?: Enumerable<MateriasScalarFieldEnum>
  }


  /**
   * materias findMany
   */
  export type materiasFindManyArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * Filter, which materias to fetch.
     */
    where?: materiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materias to fetch.
     */
    orderBy?: Enumerable<materiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materias.
     */
    cursor?: materiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materias.
     */
    skip?: number
    distinct?: Enumerable<MateriasScalarFieldEnum>
  }


  /**
   * materias create
   */
  export type materiasCreateArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * The data needed to create a materias.
     */
    data: XOR<materiasCreateInput, materiasUncheckedCreateInput>
  }


  /**
   * materias createMany
   */
  export type materiasCreateManyArgs = {
    /**
     * The data used to create many materias.
     */
    data: Enumerable<materiasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * materias update
   */
  export type materiasUpdateArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * The data needed to update a materias.
     */
    data: XOR<materiasUpdateInput, materiasUncheckedUpdateInput>
    /**
     * Choose, which materias to update.
     */
    where: materiasWhereUniqueInput
  }


  /**
   * materias updateMany
   */
  export type materiasUpdateManyArgs = {
    /**
     * The data used to update materias.
     */
    data: XOR<materiasUpdateManyMutationInput, materiasUncheckedUpdateManyInput>
    /**
     * Filter which materias to update
     */
    where?: materiasWhereInput
  }


  /**
   * materias upsert
   */
  export type materiasUpsertArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * The filter to search for the materias to update in case it exists.
     */
    where: materiasWhereUniqueInput
    /**
     * In case the materias found by the `where` argument doesn't exist, create a new materias with this data.
     */
    create: XOR<materiasCreateInput, materiasUncheckedCreateInput>
    /**
     * In case the materias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<materiasUpdateInput, materiasUncheckedUpdateInput>
  }


  /**
   * materias delete
   */
  export type materiasDeleteArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
    /**
     * Filter which materias to delete.
     */
    where: materiasWhereUniqueInput
  }


  /**
   * materias deleteMany
   */
  export type materiasDeleteManyArgs = {
    /**
     * Filter which materias to delete
     */
    where?: materiasWhereInput
  }


  /**
   * materias.inscripciones
   */
  export type materias$inscripcionesArgs = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inscripcionesInclude | null
    where?: inscripcionesWhereInput
    orderBy?: Enumerable<inscripcionesOrderByWithRelationInput>
    cursor?: inscripcionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InscripcionesScalarFieldEnum>
  }


  /**
   * materias without action
   */
  export type materiasArgs = {
    /**
     * Select specific fields to fetch from the materias
     */
    select?: materiasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materiasInclude | null
  }



  /**
   * Model usuarios
   */


  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    estado: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    estado: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    nombre_usuario: string | null
    correo_electronico: string | null
    estado: number | null
  }

  export type UsuariosMaxAggregateOutputType = {
    nombre_usuario: string | null
    correo_electronico: string | null
    estado: number | null
  }

  export type UsuariosCountAggregateOutputType = {
    nombre_usuario: number
    correo_electronico: number
    estado: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    estado?: true
  }

  export type UsuariosSumAggregateInputType = {
    estado?: true
  }

  export type UsuariosMinAggregateInputType = {
    nombre_usuario?: true
    correo_electronico?: true
    estado?: true
  }

  export type UsuariosMaxAggregateInputType = {
    nombre_usuario?: true
    correo_electronico?: true
    estado?: true
  }

  export type UsuariosCountAggregateInputType = {
    nombre_usuario?: true
    correo_electronico?: true
    estado?: true
    _all?: true
  }

  export type UsuariosAggregateArgs = {
    /**
     * Filter which usuarios to aggregate.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type UsuariosGroupByArgs = {
    where?: usuariosWhereInput
    orderBy?: Enumerable<usuariosOrderByWithAggregationInput>
    by: UsuariosScalarFieldEnum[]
    having?: usuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }


  export type UsuariosGroupByOutputType = {
    nombre_usuario: string
    correo_electronico: string
    estado: number
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends UsuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type usuariosSelect = {
    nombre_usuario?: boolean
    correo_electronico?: boolean
    estado?: boolean
    credenciales?: boolean | credencialesArgs
  }


  export type usuariosInclude = {
    credenciales?: boolean | credencialesArgs
  }

  export type usuariosGetPayload<S extends boolean | null | undefined | usuariosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuarios :
    S extends undefined ? never :
    S extends { include: any } & (usuariosArgs | usuariosFindManyArgs)
    ? usuarios  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'credenciales' ? credencialesGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (usuariosArgs | usuariosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'credenciales' ? credencialesGetPayload<S['select'][P]> | null :  P extends keyof usuarios ? usuarios[P] : never
  } 
      : usuarios


  type usuariosCountArgs = 
    Omit<usuariosFindManyArgs, 'select' | 'include'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface usuariosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {usuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuariosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuariosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuarios'> extends True ? Prisma__usuariosClient<usuariosGetPayload<T>> : Prisma__usuariosClient<usuariosGetPayload<T> | null, null>

    /**
     * Find one Usuarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuariosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuariosFindUniqueOrThrowArgs>
    ): Prisma__usuariosClient<usuariosGetPayload<T>>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuariosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuariosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuarios'> extends True ? Prisma__usuariosClient<usuariosGetPayload<T>> : Prisma__usuariosClient<usuariosGetPayload<T> | null, null>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuariosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuariosFindFirstOrThrowArgs>
    ): Prisma__usuariosClient<usuariosGetPayload<T>>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `nombre_usuario`
     * const usuariosWithNombre_usuarioOnly = await prisma.usuarios.findMany({ select: { nombre_usuario: true } })
     * 
    **/
    findMany<T extends usuariosFindManyArgs>(
      args?: SelectSubset<T, usuariosFindManyArgs>
    ): Prisma.PrismaPromise<Array<usuariosGetPayload<T>>>

    /**
     * Create a Usuarios.
     * @param {usuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
    **/
    create<T extends usuariosCreateArgs>(
      args: SelectSubset<T, usuariosCreateArgs>
    ): Prisma__usuariosClient<usuariosGetPayload<T>>

    /**
     * Create many Usuarios.
     *     @param {usuariosCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuarios = await prisma.usuarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuariosCreateManyArgs>(
      args?: SelectSubset<T, usuariosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios.
     * @param {usuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
    **/
    delete<T extends usuariosDeleteArgs>(
      args: SelectSubset<T, usuariosDeleteArgs>
    ): Prisma__usuariosClient<usuariosGetPayload<T>>

    /**
     * Update one Usuarios.
     * @param {usuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuariosUpdateArgs>(
      args: SelectSubset<T, usuariosUpdateArgs>
    ): Prisma__usuariosClient<usuariosGetPayload<T>>

    /**
     * Delete zero or more Usuarios.
     * @param {usuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuariosDeleteManyArgs>(
      args?: SelectSubset<T, usuariosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuariosUpdateManyArgs>(
      args: SelectSubset<T, usuariosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {usuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
    **/
    upsert<T extends usuariosUpsertArgs>(
      args: SelectSubset<T, usuariosUpsertArgs>
    ): Prisma__usuariosClient<usuariosGetPayload<T>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuariosCountArgs>(
      args?: Subset<T, usuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuariosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    credenciales<T extends credencialesArgs= {}>(args?: Subset<T, credencialesArgs>): Prisma__credencialesClient<credencialesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuarios base type for findUnique actions
   */
  export type usuariosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findUnique
   */
  export interface usuariosFindUniqueArgs extends usuariosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuarios findUniqueOrThrow
   */
  export type usuariosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }


  /**
   * usuarios base type for findFirst actions
   */
  export type usuariosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: Enumerable<UsuariosScalarFieldEnum>
  }

  /**
   * usuarios findFirst
   */
  export interface usuariosFindFirstArgs extends usuariosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuarios findFirstOrThrow
   */
  export type usuariosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: Enumerable<UsuariosScalarFieldEnum>
  }


  /**
   * usuarios findMany
   */
  export type usuariosFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: Enumerable<UsuariosScalarFieldEnum>
  }


  /**
   * usuarios create
   */
  export type usuariosCreateArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * The data needed to create a usuarios.
     */
    data: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
  }


  /**
   * usuarios createMany
   */
  export type usuariosCreateManyArgs = {
    /**
     * The data used to create many usuarios.
     */
    data: Enumerable<usuariosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuarios update
   */
  export type usuariosUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * The data needed to update a usuarios.
     */
    data: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
    /**
     * Choose, which usuarios to update.
     */
    where: usuariosWhereUniqueInput
  }


  /**
   * usuarios updateMany
   */
  export type usuariosUpdateManyArgs = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuariosUpdateManyMutationInput, usuariosUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuariosWhereInput
  }


  /**
   * usuarios upsert
   */
  export type usuariosUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * The filter to search for the usuarios to update in case it exists.
     */
    where: usuariosWhereUniqueInput
    /**
     * In case the usuarios found by the `where` argument doesn't exist, create a new usuarios with this data.
     */
    create: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
    /**
     * In case the usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
  }


  /**
   * usuarios delete
   */
  export type usuariosDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
    /**
     * Filter which usuarios to delete.
     */
    where: usuariosWhereUniqueInput
  }


  /**
   * usuarios deleteMany
   */
  export type usuariosDeleteManyArgs = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuariosWhereInput
  }


  /**
   * usuarios without action
   */
  export type usuariosArgs = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuariosInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CredencialesScalarFieldEnum: {
    usuario: 'usuario',
    contrasena: 'contrasena'
  };

  export type CredencialesScalarFieldEnum = (typeof CredencialesScalarFieldEnum)[keyof typeof CredencialesScalarFieldEnum]


  export const EstudiantesScalarFieldEnum: {
    codigo: 'codigo',
    nombre: 'nombre',
    apellido: 'apellido',
    tipo_documento: 'tipo_documento',
    numero_documento: 'numero_documento',
    estado: 'estado',
    genero: 'genero',
    path: 'path'
  };

  export type EstudiantesScalarFieldEnum = (typeof EstudiantesScalarFieldEnum)[keyof typeof EstudiantesScalarFieldEnum]


  export const InscripcionesScalarFieldEnum: {
    id_inscripcion: 'id_inscripcion',
    codigo_estudiante: 'codigo_estudiante',
    codigo_materia: 'codigo_materia',
    fecha_inscripcion: 'fecha_inscripcion'
  };

  export type InscripcionesScalarFieldEnum = (typeof InscripcionesScalarFieldEnum)[keyof typeof InscripcionesScalarFieldEnum]


  export const MateriasScalarFieldEnum: {
    codigo: 'codigo',
    nombre: 'nombre',
    cupos: 'cupos',
    estado: 'estado'
  };

  export type MateriasScalarFieldEnum = (typeof MateriasScalarFieldEnum)[keyof typeof MateriasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuariosScalarFieldEnum: {
    nombre_usuario: 'nombre_usuario',
    correo_electronico: 'correo_electronico',
    estado: 'estado'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type credencialesWhereInput = {
    AND?: Enumerable<credencialesWhereInput>
    OR?: Enumerable<credencialesWhereInput>
    NOT?: Enumerable<credencialesWhereInput>
    usuario?: StringFilter | string
    contrasena?: StringFilter | string
    usuarios?: XOR<UsuariosRelationFilter, usuariosWhereInput>
  }

  export type credencialesOrderByWithRelationInput = {
    usuario?: SortOrder
    contrasena?: SortOrder
    usuarios?: usuariosOrderByWithRelationInput
  }

  export type credencialesWhereUniqueInput = {
    usuario?: string
  }

  export type credencialesOrderByWithAggregationInput = {
    usuario?: SortOrder
    contrasena?: SortOrder
    _count?: credencialesCountOrderByAggregateInput
    _max?: credencialesMaxOrderByAggregateInput
    _min?: credencialesMinOrderByAggregateInput
  }

  export type credencialesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<credencialesScalarWhereWithAggregatesInput>
    OR?: Enumerable<credencialesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<credencialesScalarWhereWithAggregatesInput>
    usuario?: StringWithAggregatesFilter | string
    contrasena?: StringWithAggregatesFilter | string
  }

  export type estudiantesWhereInput = {
    AND?: Enumerable<estudiantesWhereInput>
    OR?: Enumerable<estudiantesWhereInput>
    NOT?: Enumerable<estudiantesWhereInput>
    codigo?: IntFilter | number
    nombre?: StringFilter | string
    apellido?: StringFilter | string
    tipo_documento?: StringFilter | string
    numero_documento?: StringFilter | string
    estado?: StringNullableFilter | string | null
    genero?: StringNullableFilter | string | null
    path?: StringFilter | string
    inscripciones?: InscripcionesListRelationFilter
  }

  export type estudiantesOrderByWithRelationInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    estado?: SortOrder
    genero?: SortOrder
    path?: SortOrder
    inscripciones?: inscripcionesOrderByRelationAggregateInput
  }

  export type estudiantesWhereUniqueInput = {
    codigo?: number
  }

  export type estudiantesOrderByWithAggregationInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    estado?: SortOrder
    genero?: SortOrder
    path?: SortOrder
    _count?: estudiantesCountOrderByAggregateInput
    _avg?: estudiantesAvgOrderByAggregateInput
    _max?: estudiantesMaxOrderByAggregateInput
    _min?: estudiantesMinOrderByAggregateInput
    _sum?: estudiantesSumOrderByAggregateInput
  }

  export type estudiantesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<estudiantesScalarWhereWithAggregatesInput>
    OR?: Enumerable<estudiantesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<estudiantesScalarWhereWithAggregatesInput>
    codigo?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    apellido?: StringWithAggregatesFilter | string
    tipo_documento?: StringWithAggregatesFilter | string
    numero_documento?: StringWithAggregatesFilter | string
    estado?: StringNullableWithAggregatesFilter | string | null
    genero?: StringNullableWithAggregatesFilter | string | null
    path?: StringWithAggregatesFilter | string
  }

  export type inscripcionesWhereInput = {
    AND?: Enumerable<inscripcionesWhereInput>
    OR?: Enumerable<inscripcionesWhereInput>
    NOT?: Enumerable<inscripcionesWhereInput>
    id_inscripcion?: IntFilter | number
    codigo_estudiante?: IntFilter | number
    codigo_materia?: IntFilter | number
    fecha_inscripcion?: DateTimeFilter | Date | string
    estudiantes?: XOR<EstudiantesRelationFilter, estudiantesWhereInput>
    materias?: XOR<MateriasRelationFilter, materiasWhereInput>
  }

  export type inscripcionesOrderByWithRelationInput = {
    id_inscripcion?: SortOrder
    codigo_estudiante?: SortOrder
    codigo_materia?: SortOrder
    fecha_inscripcion?: SortOrder
    estudiantes?: estudiantesOrderByWithRelationInput
    materias?: materiasOrderByWithRelationInput
  }

  export type inscripcionesWhereUniqueInput = {
    id_inscripcion?: number
  }

  export type inscripcionesOrderByWithAggregationInput = {
    id_inscripcion?: SortOrder
    codigo_estudiante?: SortOrder
    codigo_materia?: SortOrder
    fecha_inscripcion?: SortOrder
    _count?: inscripcionesCountOrderByAggregateInput
    _avg?: inscripcionesAvgOrderByAggregateInput
    _max?: inscripcionesMaxOrderByAggregateInput
    _min?: inscripcionesMinOrderByAggregateInput
    _sum?: inscripcionesSumOrderByAggregateInput
  }

  export type inscripcionesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<inscripcionesScalarWhereWithAggregatesInput>
    OR?: Enumerable<inscripcionesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<inscripcionesScalarWhereWithAggregatesInput>
    id_inscripcion?: IntWithAggregatesFilter | number
    codigo_estudiante?: IntWithAggregatesFilter | number
    codigo_materia?: IntWithAggregatesFilter | number
    fecha_inscripcion?: DateTimeWithAggregatesFilter | Date | string
  }

  export type materiasWhereInput = {
    AND?: Enumerable<materiasWhereInput>
    OR?: Enumerable<materiasWhereInput>
    NOT?: Enumerable<materiasWhereInput>
    codigo?: IntFilter | number
    nombre?: StringFilter | string
    cupos?: IntNullableFilter | number | null
    estado?: StringNullableFilter | string | null
    inscripciones?: InscripcionesListRelationFilter
  }

  export type materiasOrderByWithRelationInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    cupos?: SortOrder
    estado?: SortOrder
    inscripciones?: inscripcionesOrderByRelationAggregateInput
  }

  export type materiasWhereUniqueInput = {
    codigo?: number
  }

  export type materiasOrderByWithAggregationInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    cupos?: SortOrder
    estado?: SortOrder
    _count?: materiasCountOrderByAggregateInput
    _avg?: materiasAvgOrderByAggregateInput
    _max?: materiasMaxOrderByAggregateInput
    _min?: materiasMinOrderByAggregateInput
    _sum?: materiasSumOrderByAggregateInput
  }

  export type materiasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<materiasScalarWhereWithAggregatesInput>
    OR?: Enumerable<materiasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<materiasScalarWhereWithAggregatesInput>
    codigo?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    cupos?: IntNullableWithAggregatesFilter | number | null
    estado?: StringNullableWithAggregatesFilter | string | null
  }

  export type usuariosWhereInput = {
    AND?: Enumerable<usuariosWhereInput>
    OR?: Enumerable<usuariosWhereInput>
    NOT?: Enumerable<usuariosWhereInput>
    nombre_usuario?: StringFilter | string
    correo_electronico?: StringFilter | string
    estado?: IntFilter | number
    credenciales?: XOR<CredencialesRelationFilter, credencialesWhereInput> | null
  }

  export type usuariosOrderByWithRelationInput = {
    nombre_usuario?: SortOrder
    correo_electronico?: SortOrder
    estado?: SortOrder
    credenciales?: credencialesOrderByWithRelationInput
  }

  export type usuariosWhereUniqueInput = {
    correo_electronico?: string
  }

  export type usuariosOrderByWithAggregationInput = {
    nombre_usuario?: SortOrder
    correo_electronico?: SortOrder
    estado?: SortOrder
    _count?: usuariosCountOrderByAggregateInput
    _avg?: usuariosAvgOrderByAggregateInput
    _max?: usuariosMaxOrderByAggregateInput
    _min?: usuariosMinOrderByAggregateInput
    _sum?: usuariosSumOrderByAggregateInput
  }

  export type usuariosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuariosScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuariosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuariosScalarWhereWithAggregatesInput>
    nombre_usuario?: StringWithAggregatesFilter | string
    correo_electronico?: StringWithAggregatesFilter | string
    estado?: IntWithAggregatesFilter | number
  }

  export type credencialesCreateInput = {
    contrasena: string
    usuarios: usuariosCreateNestedOneWithoutCredencialesInput
  }

  export type credencialesUncheckedCreateInput = {
    usuario: string
    contrasena: string
  }

  export type credencialesUpdateInput = {
    contrasena?: StringFieldUpdateOperationsInput | string
    usuarios?: usuariosUpdateOneRequiredWithoutCredencialesNestedInput
  }

  export type credencialesUncheckedUpdateInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type credencialesCreateManyInput = {
    usuario: string
    contrasena: string
  }

  export type credencialesUpdateManyMutationInput = {
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type credencialesUncheckedUpdateManyInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type estudiantesCreateInput = {
    nombre: string
    apellido: string
    tipo_documento: string
    numero_documento: string
    estado?: string | null
    genero?: string | null
    path: string
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudiantesInput
  }

  export type estudiantesUncheckedCreateInput = {
    codigo?: number
    nombre: string
    apellido: string
    tipo_documento: string
    numero_documento: string
    estado?: string | null
    genero?: string | null
    path: string
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudiantesInput
  }

  export type estudiantesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    tipo_documento?: StringFieldUpdateOperationsInput | string
    numero_documento?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    inscripciones?: inscripcionesUpdateManyWithoutEstudiantesNestedInput
  }

  export type estudiantesUncheckedUpdateInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    tipo_documento?: StringFieldUpdateOperationsInput | string
    numero_documento?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudiantesNestedInput
  }

  export type estudiantesCreateManyInput = {
    codigo?: number
    nombre: string
    apellido: string
    tipo_documento: string
    numero_documento: string
    estado?: string | null
    genero?: string | null
    path: string
  }

  export type estudiantesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    tipo_documento?: StringFieldUpdateOperationsInput | string
    numero_documento?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
  }

  export type estudiantesUncheckedUpdateManyInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    tipo_documento?: StringFieldUpdateOperationsInput | string
    numero_documento?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
  }

  export type inscripcionesCreateInput = {
    fecha_inscripcion: Date | string
    estudiantes: estudiantesCreateNestedOneWithoutInscripcionesInput
    materias: materiasCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateInput = {
    id_inscripcion?: number
    codigo_estudiante: number
    codigo_materia: number
    fecha_inscripcion: Date | string
  }

  export type inscripcionesUpdateInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
    materias?: materiasUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateInput = {
    id_inscripcion?: IntFieldUpdateOperationsInput | number
    codigo_estudiante?: IntFieldUpdateOperationsInput | number
    codigo_materia?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesCreateManyInput = {
    id_inscripcion?: number
    codigo_estudiante: number
    codigo_materia: number
    fecha_inscripcion: Date | string
  }

  export type inscripcionesUpdateManyMutationInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUncheckedUpdateManyInput = {
    id_inscripcion?: IntFieldUpdateOperationsInput | number
    codigo_estudiante?: IntFieldUpdateOperationsInput | number
    codigo_materia?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materiasCreateInput = {
    nombre: string
    cupos?: number | null
    estado?: string | null
    inscripciones?: inscripcionesCreateNestedManyWithoutMateriasInput
  }

  export type materiasUncheckedCreateInput = {
    codigo?: number
    nombre: string
    cupos?: number | null
    estado?: string | null
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutMateriasInput
  }

  export type materiasUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cupos?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    inscripciones?: inscripcionesUpdateManyWithoutMateriasNestedInput
  }

  export type materiasUncheckedUpdateInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cupos?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutMateriasNestedInput
  }

  export type materiasCreateManyInput = {
    codigo?: number
    nombre: string
    cupos?: number | null
    estado?: string | null
  }

  export type materiasUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cupos?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type materiasUncheckedUpdateManyInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cupos?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuariosCreateInput = {
    nombre_usuario: string
    correo_electronico: string
    estado: number
    credenciales?: credencialesCreateNestedOneWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateInput = {
    nombre_usuario: string
    correo_electronico: string
    estado: number
    credenciales?: credencialesUncheckedCreateNestedOneWithoutUsuariosInput
  }

  export type usuariosUpdateInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    credenciales?: credencialesUpdateOneWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    credenciales?: credencialesUncheckedUpdateOneWithoutUsuariosNestedInput
  }

  export type usuariosCreateManyInput = {
    nombre_usuario: string
    correo_electronico: string
    estado: number
  }

  export type usuariosUpdateManyMutationInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
  }

  export type usuariosUncheckedUpdateManyInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type UsuariosRelationFilter = {
    is?: usuariosWhereInput
    isNot?: usuariosWhereInput
  }

  export type credencialesCountOrderByAggregateInput = {
    usuario?: SortOrder
    contrasena?: SortOrder
  }

  export type credencialesMaxOrderByAggregateInput = {
    usuario?: SortOrder
    contrasena?: SortOrder
  }

  export type credencialesMinOrderByAggregateInput = {
    usuario?: SortOrder
    contrasena?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type InscripcionesListRelationFilter = {
    every?: inscripcionesWhereInput
    some?: inscripcionesWhereInput
    none?: inscripcionesWhereInput
  }

  export type inscripcionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estudiantesCountOrderByAggregateInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    estado?: SortOrder
    genero?: SortOrder
    path?: SortOrder
  }

  export type estudiantesAvgOrderByAggregateInput = {
    codigo?: SortOrder
  }

  export type estudiantesMaxOrderByAggregateInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    estado?: SortOrder
    genero?: SortOrder
    path?: SortOrder
  }

  export type estudiantesMinOrderByAggregateInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    estado?: SortOrder
    genero?: SortOrder
    path?: SortOrder
  }

  export type estudiantesSumOrderByAggregateInput = {
    codigo?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type EstudiantesRelationFilter = {
    is?: estudiantesWhereInput
    isNot?: estudiantesWhereInput
  }

  export type MateriasRelationFilter = {
    is?: materiasWhereInput
    isNot?: materiasWhereInput
  }

  export type inscripcionesCountOrderByAggregateInput = {
    id_inscripcion?: SortOrder
    codigo_estudiante?: SortOrder
    codigo_materia?: SortOrder
    fecha_inscripcion?: SortOrder
  }

  export type inscripcionesAvgOrderByAggregateInput = {
    id_inscripcion?: SortOrder
    codigo_estudiante?: SortOrder
    codigo_materia?: SortOrder
  }

  export type inscripcionesMaxOrderByAggregateInput = {
    id_inscripcion?: SortOrder
    codigo_estudiante?: SortOrder
    codigo_materia?: SortOrder
    fecha_inscripcion?: SortOrder
  }

  export type inscripcionesMinOrderByAggregateInput = {
    id_inscripcion?: SortOrder
    codigo_estudiante?: SortOrder
    codigo_materia?: SortOrder
    fecha_inscripcion?: SortOrder
  }

  export type inscripcionesSumOrderByAggregateInput = {
    id_inscripcion?: SortOrder
    codigo_estudiante?: SortOrder
    codigo_materia?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type materiasCountOrderByAggregateInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    cupos?: SortOrder
    estado?: SortOrder
  }

  export type materiasAvgOrderByAggregateInput = {
    codigo?: SortOrder
    cupos?: SortOrder
  }

  export type materiasMaxOrderByAggregateInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    cupos?: SortOrder
    estado?: SortOrder
  }

  export type materiasMinOrderByAggregateInput = {
    codigo?: SortOrder
    nombre?: SortOrder
    cupos?: SortOrder
    estado?: SortOrder
  }

  export type materiasSumOrderByAggregateInput = {
    codigo?: SortOrder
    cupos?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type CredencialesRelationFilter = {
    is?: credencialesWhereInput | null
    isNot?: credencialesWhereInput | null
  }

  export type usuariosCountOrderByAggregateInput = {
    nombre_usuario?: SortOrder
    correo_electronico?: SortOrder
    estado?: SortOrder
  }

  export type usuariosAvgOrderByAggregateInput = {
    estado?: SortOrder
  }

  export type usuariosMaxOrderByAggregateInput = {
    nombre_usuario?: SortOrder
    correo_electronico?: SortOrder
    estado?: SortOrder
  }

  export type usuariosMinOrderByAggregateInput = {
    nombre_usuario?: SortOrder
    correo_electronico?: SortOrder
    estado?: SortOrder
  }

  export type usuariosSumOrderByAggregateInput = {
    estado?: SortOrder
  }

  export type usuariosCreateNestedOneWithoutCredencialesInput = {
    create?: XOR<usuariosCreateWithoutCredencialesInput, usuariosUncheckedCreateWithoutCredencialesInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutCredencialesInput
    connect?: usuariosWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type usuariosUpdateOneRequiredWithoutCredencialesNestedInput = {
    create?: XOR<usuariosCreateWithoutCredencialesInput, usuariosUncheckedCreateWithoutCredencialesInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutCredencialesInput
    upsert?: usuariosUpsertWithoutCredencialesInput
    connect?: usuariosWhereUniqueInput
    update?: XOR<usuariosUpdateWithoutCredencialesInput, usuariosUncheckedUpdateWithoutCredencialesInput>
  }

  export type inscripcionesCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutEstudiantesInput>, Enumerable<inscripcionesUncheckedCreateWithoutEstudiantesInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutEstudiantesInput>
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    connect?: Enumerable<inscripcionesWhereUniqueInput>
  }

  export type inscripcionesUncheckedCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutEstudiantesInput>, Enumerable<inscripcionesUncheckedCreateWithoutEstudiantesInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutEstudiantesInput>
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    connect?: Enumerable<inscripcionesWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type inscripcionesUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutEstudiantesInput>, Enumerable<inscripcionesUncheckedCreateWithoutEstudiantesInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutEstudiantesInput>
    upsert?: Enumerable<inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput>
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    set?: Enumerable<inscripcionesWhereUniqueInput>
    disconnect?: Enumerable<inscripcionesWhereUniqueInput>
    delete?: Enumerable<inscripcionesWhereUniqueInput>
    connect?: Enumerable<inscripcionesWhereUniqueInput>
    update?: Enumerable<inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput>
    updateMany?: Enumerable<inscripcionesUpdateManyWithWhereWithoutEstudiantesInput>
    deleteMany?: Enumerable<inscripcionesScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type inscripcionesUncheckedUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutEstudiantesInput>, Enumerable<inscripcionesUncheckedCreateWithoutEstudiantesInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutEstudiantesInput>
    upsert?: Enumerable<inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput>
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    set?: Enumerable<inscripcionesWhereUniqueInput>
    disconnect?: Enumerable<inscripcionesWhereUniqueInput>
    delete?: Enumerable<inscripcionesWhereUniqueInput>
    connect?: Enumerable<inscripcionesWhereUniqueInput>
    update?: Enumerable<inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput>
    updateMany?: Enumerable<inscripcionesUpdateManyWithWhereWithoutEstudiantesInput>
    deleteMany?: Enumerable<inscripcionesScalarWhereInput>
  }

  export type estudiantesCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutInscripcionesInput
    connect?: estudiantesWhereUniqueInput
  }

  export type materiasCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<materiasCreateWithoutInscripcionesInput, materiasUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: materiasCreateOrConnectWithoutInscripcionesInput
    connect?: materiasWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutInscripcionesInput
    upsert?: estudiantesUpsertWithoutInscripcionesInput
    connect?: estudiantesWhereUniqueInput
    update?: XOR<estudiantesUpdateWithoutInscripcionesInput, estudiantesUncheckedUpdateWithoutInscripcionesInput>
  }

  export type materiasUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<materiasCreateWithoutInscripcionesInput, materiasUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: materiasCreateOrConnectWithoutInscripcionesInput
    upsert?: materiasUpsertWithoutInscripcionesInput
    connect?: materiasWhereUniqueInput
    update?: XOR<materiasUpdateWithoutInscripcionesInput, materiasUncheckedUpdateWithoutInscripcionesInput>
  }

  export type inscripcionesCreateNestedManyWithoutMateriasInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutMateriasInput>, Enumerable<inscripcionesUncheckedCreateWithoutMateriasInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutMateriasInput>
    createMany?: inscripcionesCreateManyMateriasInputEnvelope
    connect?: Enumerable<inscripcionesWhereUniqueInput>
  }

  export type inscripcionesUncheckedCreateNestedManyWithoutMateriasInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutMateriasInput>, Enumerable<inscripcionesUncheckedCreateWithoutMateriasInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutMateriasInput>
    createMany?: inscripcionesCreateManyMateriasInputEnvelope
    connect?: Enumerable<inscripcionesWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type inscripcionesUpdateManyWithoutMateriasNestedInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutMateriasInput>, Enumerable<inscripcionesUncheckedCreateWithoutMateriasInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutMateriasInput>
    upsert?: Enumerable<inscripcionesUpsertWithWhereUniqueWithoutMateriasInput>
    createMany?: inscripcionesCreateManyMateriasInputEnvelope
    set?: Enumerable<inscripcionesWhereUniqueInput>
    disconnect?: Enumerable<inscripcionesWhereUniqueInput>
    delete?: Enumerable<inscripcionesWhereUniqueInput>
    connect?: Enumerable<inscripcionesWhereUniqueInput>
    update?: Enumerable<inscripcionesUpdateWithWhereUniqueWithoutMateriasInput>
    updateMany?: Enumerable<inscripcionesUpdateManyWithWhereWithoutMateriasInput>
    deleteMany?: Enumerable<inscripcionesScalarWhereInput>
  }

  export type inscripcionesUncheckedUpdateManyWithoutMateriasNestedInput = {
    create?: XOR<Enumerable<inscripcionesCreateWithoutMateriasInput>, Enumerable<inscripcionesUncheckedCreateWithoutMateriasInput>>
    connectOrCreate?: Enumerable<inscripcionesCreateOrConnectWithoutMateriasInput>
    upsert?: Enumerable<inscripcionesUpsertWithWhereUniqueWithoutMateriasInput>
    createMany?: inscripcionesCreateManyMateriasInputEnvelope
    set?: Enumerable<inscripcionesWhereUniqueInput>
    disconnect?: Enumerable<inscripcionesWhereUniqueInput>
    delete?: Enumerable<inscripcionesWhereUniqueInput>
    connect?: Enumerable<inscripcionesWhereUniqueInput>
    update?: Enumerable<inscripcionesUpdateWithWhereUniqueWithoutMateriasInput>
    updateMany?: Enumerable<inscripcionesUpdateManyWithWhereWithoutMateriasInput>
    deleteMany?: Enumerable<inscripcionesScalarWhereInput>
  }

  export type credencialesCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<credencialesCreateWithoutUsuariosInput, credencialesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: credencialesCreateOrConnectWithoutUsuariosInput
    connect?: credencialesWhereUniqueInput
  }

  export type credencialesUncheckedCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<credencialesCreateWithoutUsuariosInput, credencialesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: credencialesCreateOrConnectWithoutUsuariosInput
    connect?: credencialesWhereUniqueInput
  }

  export type credencialesUpdateOneWithoutUsuariosNestedInput = {
    create?: XOR<credencialesCreateWithoutUsuariosInput, credencialesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: credencialesCreateOrConnectWithoutUsuariosInput
    upsert?: credencialesUpsertWithoutUsuariosInput
    disconnect?: boolean
    delete?: boolean
    connect?: credencialesWhereUniqueInput
    update?: XOR<credencialesUpdateWithoutUsuariosInput, credencialesUncheckedUpdateWithoutUsuariosInput>
  }

  export type credencialesUncheckedUpdateOneWithoutUsuariosNestedInput = {
    create?: XOR<credencialesCreateWithoutUsuariosInput, credencialesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: credencialesCreateOrConnectWithoutUsuariosInput
    upsert?: credencialesUpsertWithoutUsuariosInput
    disconnect?: boolean
    delete?: boolean
    connect?: credencialesWhereUniqueInput
    update?: XOR<credencialesUpdateWithoutUsuariosInput, credencialesUncheckedUpdateWithoutUsuariosInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type usuariosCreateWithoutCredencialesInput = {
    nombre_usuario: string
    correo_electronico: string
    estado: number
  }

  export type usuariosUncheckedCreateWithoutCredencialesInput = {
    nombre_usuario: string
    correo_electronico: string
    estado: number
  }

  export type usuariosCreateOrConnectWithoutCredencialesInput = {
    where: usuariosWhereUniqueInput
    create: XOR<usuariosCreateWithoutCredencialesInput, usuariosUncheckedCreateWithoutCredencialesInput>
  }

  export type usuariosUpsertWithoutCredencialesInput = {
    update: XOR<usuariosUpdateWithoutCredencialesInput, usuariosUncheckedUpdateWithoutCredencialesInput>
    create: XOR<usuariosCreateWithoutCredencialesInput, usuariosUncheckedCreateWithoutCredencialesInput>
  }

  export type usuariosUpdateWithoutCredencialesInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
  }

  export type usuariosUncheckedUpdateWithoutCredencialesInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
  }

  export type inscripcionesCreateWithoutEstudiantesInput = {
    fecha_inscripcion: Date | string
    materias: materiasCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateWithoutEstudiantesInput = {
    id_inscripcion?: number
    codigo_materia: number
    fecha_inscripcion: Date | string
  }

  export type inscripcionesCreateOrConnectWithoutEstudiantesInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput>
  }

  export type inscripcionesCreateManyEstudiantesInputEnvelope = {
    data: Enumerable<inscripcionesCreateManyEstudiantesInput>
    skipDuplicates?: boolean
  }

  export type inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput = {
    where: inscripcionesWhereUniqueInput
    update: XOR<inscripcionesUpdateWithoutEstudiantesInput, inscripcionesUncheckedUpdateWithoutEstudiantesInput>
    create: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput>
  }

  export type inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput = {
    where: inscripcionesWhereUniqueInput
    data: XOR<inscripcionesUpdateWithoutEstudiantesInput, inscripcionesUncheckedUpdateWithoutEstudiantesInput>
  }

  export type inscripcionesUpdateManyWithWhereWithoutEstudiantesInput = {
    where: inscripcionesScalarWhereInput
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyWithoutInscripcionesInput>
  }

  export type inscripcionesScalarWhereInput = {
    AND?: Enumerable<inscripcionesScalarWhereInput>
    OR?: Enumerable<inscripcionesScalarWhereInput>
    NOT?: Enumerable<inscripcionesScalarWhereInput>
    id_inscripcion?: IntFilter | number
    codigo_estudiante?: IntFilter | number
    codigo_materia?: IntFilter | number
    fecha_inscripcion?: DateTimeFilter | Date | string
  }

  export type estudiantesCreateWithoutInscripcionesInput = {
    nombre: string
    apellido: string
    tipo_documento: string
    numero_documento: string
    estado?: string | null
    genero?: string | null
    path: string
  }

  export type estudiantesUncheckedCreateWithoutInscripcionesInput = {
    codigo?: number
    nombre: string
    apellido: string
    tipo_documento: string
    numero_documento: string
    estado?: string | null
    genero?: string | null
    path: string
  }

  export type estudiantesCreateOrConnectWithoutInscripcionesInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
  }

  export type materiasCreateWithoutInscripcionesInput = {
    nombre: string
    cupos?: number | null
    estado?: string | null
  }

  export type materiasUncheckedCreateWithoutInscripcionesInput = {
    codigo?: number
    nombre: string
    cupos?: number | null
    estado?: string | null
  }

  export type materiasCreateOrConnectWithoutInscripcionesInput = {
    where: materiasWhereUniqueInput
    create: XOR<materiasCreateWithoutInscripcionesInput, materiasUncheckedCreateWithoutInscripcionesInput>
  }

  export type estudiantesUpsertWithoutInscripcionesInput = {
    update: XOR<estudiantesUpdateWithoutInscripcionesInput, estudiantesUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
  }

  export type estudiantesUpdateWithoutInscripcionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    tipo_documento?: StringFieldUpdateOperationsInput | string
    numero_documento?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
  }

  export type estudiantesUncheckedUpdateWithoutInscripcionesInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    tipo_documento?: StringFieldUpdateOperationsInput | string
    numero_documento?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
  }

  export type materiasUpsertWithoutInscripcionesInput = {
    update: XOR<materiasUpdateWithoutInscripcionesInput, materiasUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<materiasCreateWithoutInscripcionesInput, materiasUncheckedCreateWithoutInscripcionesInput>
  }

  export type materiasUpdateWithoutInscripcionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cupos?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type materiasUncheckedUpdateWithoutInscripcionesInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cupos?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inscripcionesCreateWithoutMateriasInput = {
    fecha_inscripcion: Date | string
    estudiantes: estudiantesCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateWithoutMateriasInput = {
    id_inscripcion?: number
    codigo_estudiante: number
    fecha_inscripcion: Date | string
  }

  export type inscripcionesCreateOrConnectWithoutMateriasInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutMateriasInput, inscripcionesUncheckedCreateWithoutMateriasInput>
  }

  export type inscripcionesCreateManyMateriasInputEnvelope = {
    data: Enumerable<inscripcionesCreateManyMateriasInput>
    skipDuplicates?: boolean
  }

  export type inscripcionesUpsertWithWhereUniqueWithoutMateriasInput = {
    where: inscripcionesWhereUniqueInput
    update: XOR<inscripcionesUpdateWithoutMateriasInput, inscripcionesUncheckedUpdateWithoutMateriasInput>
    create: XOR<inscripcionesCreateWithoutMateriasInput, inscripcionesUncheckedCreateWithoutMateriasInput>
  }

  export type inscripcionesUpdateWithWhereUniqueWithoutMateriasInput = {
    where: inscripcionesWhereUniqueInput
    data: XOR<inscripcionesUpdateWithoutMateriasInput, inscripcionesUncheckedUpdateWithoutMateriasInput>
  }

  export type inscripcionesUpdateManyWithWhereWithoutMateriasInput = {
    where: inscripcionesScalarWhereInput
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyWithoutInscripcionesInput>
  }

  export type credencialesCreateWithoutUsuariosInput = {
    contrasena: string
  }

  export type credencialesUncheckedCreateWithoutUsuariosInput = {
    contrasena: string
  }

  export type credencialesCreateOrConnectWithoutUsuariosInput = {
    where: credencialesWhereUniqueInput
    create: XOR<credencialesCreateWithoutUsuariosInput, credencialesUncheckedCreateWithoutUsuariosInput>
  }

  export type credencialesUpsertWithoutUsuariosInput = {
    update: XOR<credencialesUpdateWithoutUsuariosInput, credencialesUncheckedUpdateWithoutUsuariosInput>
    create: XOR<credencialesCreateWithoutUsuariosInput, credencialesUncheckedCreateWithoutUsuariosInput>
  }

  export type credencialesUpdateWithoutUsuariosInput = {
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type credencialesUncheckedUpdateWithoutUsuariosInput = {
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type inscripcionesCreateManyEstudiantesInput = {
    id_inscripcion?: number
    codigo_materia: number
    fecha_inscripcion: Date | string
  }

  export type inscripcionesUpdateWithoutEstudiantesInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    materias?: materiasUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutEstudiantesInput = {
    id_inscripcion?: IntFieldUpdateOperationsInput | number
    codigo_materia?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUncheckedUpdateManyWithoutInscripcionesInput = {
    id_inscripcion?: IntFieldUpdateOperationsInput | number
    codigo_materia?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesCreateManyMateriasInput = {
    id_inscripcion?: number
    codigo_estudiante: number
    fecha_inscripcion: Date | string
  }

  export type inscripcionesUpdateWithoutMateriasInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutMateriasInput = {
    id_inscripcion?: IntFieldUpdateOperationsInput | number
    codigo_estudiante?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}